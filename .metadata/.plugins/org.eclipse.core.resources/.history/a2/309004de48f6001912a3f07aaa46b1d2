package test;

import PCB.PCB;
import queue.ReadyQueue;
import scheduler.RoundRobin;
import scheduler.ShortestJobFirst;

public class test {

	public static void main(String args[]) { 
//			输入进程列表信息
			PCB [] pcb;
			pcb = new PCB[7];
	        pcb[0] = new PCB("pcb0",10,3);
	        pcb[1] = new PCB("pcb1",40,4);
	        pcb[2] = new PCB("pcb2",50,5);
	        pcb[3] = new PCB("pcb3",80,10);
	        pcb[4] = new PCB("pcb4",60,2);
	        pcb[5] = new PCB("pcb5",78,9);
	        pcb[6] = new PCB("pcb6",5,14);

/*	        RoundRobin RR = new RoundRobin();					//定义一个时间片轮转算法，内置空就绪队列
*/	        ShortestJobFirst S1=new ShortestJobFirst();
	        for(int i=0;i<7;i++)
			S1.rqueueInit(pcb[i]);									//将进程列表放入该算法中，初始化该就绪队列，转换为待执行状态
	       
	        System.out.println("短作业优先");
	        System.out.println("当前时间\t\t进程\t\t执行时间\t\t就绪队列");
	        System.out.println("只执行一个pcb");
	        ReadyQueue rqueue  = S1.run();						//只执行一次就绪队列中第一个pcb进程
	         S1.run();	
	        System.out.println("执行12个时间单位");
	        ShortestJobFirst S2=new ShortestJobFirst();
	        for(int i=0;i<7;i++)
			S1.rqueueInit(pcb[i]);
	        ReadyQueue rqueue2 	=   S2.run_in_time(12);				//按规定时间执行该算法中的就绪队列
	        System.out.println("执行完该就绪队列");
	        ShortestJobFirst S3=new ShortestJobFirst();
	        for(int i=0;i<7;i++)
			S1.rqueueInit(pcb[i]);	
	        S3.run_all();					//执行完该就绪队列

	        

    } 
	

}
