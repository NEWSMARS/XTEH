package queue;

import PCB.PCB;

//多级调度
public class MultilevelQueue {
	private PCB[] active;
	private PCB[] expired;
	private boolean newPcb; //true 为 有新的进程进入， 默认为false；
	
	
	MultilevelQueue(){
		active = new PCB[4];
		expired = new PCB[4];
		newPcb = false;
	}
	
	
	public void addPcb(PCB pcb){	//添加一个新进程
		
		newPcb = true;
		if(pcb==null) {
			System.out.println("pcb=null,返回");
			newPcb = false;
			return;
		}
		//可以考虑使用 switch  case语句
		if("系统进程".equals(pcb.getCategory())) {
			addPcbToHead(pcb,active[0]);
		}
		else if("实时进程".equals(pcb.getCategory())) {
			addPcbToHead(pcb,active[1]);
		}
		else if("交互进程".equals(pcb.getCategory())) {
			addPcbToHead(pcb,active[1]);
		}
		else {	//批处理进程以及其它所有进程都放到最后的链表
			addPcbToHead(pcb,active[3]);
		}
		
		newPcb = false;
	}
	public void addPcbToHead(PCB pcb,PCB ArrayHead) {		//在链尾添加
		PCB head = ArrayHead;			//链表的头
		PCB tail = head.getPrev_run();	//链表的尾
		
		pcb.setNext_run(head);
		pcb.setPrev_run(tail);
		tail.setNext_run(pcb);
		head.setPrev_run(pcb);
	}
	
	//一次性把所有已进入队列的进程执行完毕
	public void run() {
		
		
		RoundRobin roundRobin = new RoundRobin();						//第二
		
		ShortestJobFirst shortestJobFirst = new ShortestJobFirst();		//最后
		
		if(active[1]!=null) {
			destroyList(active[1].getNext_run());
			roundRobin.rqueueInit(active[1].getNext_run());//因为接收的数据类型需要改为PCB，所以提示错误
			roundRobin.run_all();
		}
		if(active[3]!=null) {
			destroyList(active[3].getNext_run());
			shortestJobFirst.rqueueInit(active[3].getNext_run());//因为接收的数据类型需要改为PCB，所以提示错误
			shortestJobFirst.run_all();
		}
		
	}
	public void destroyList(PCB head) {		//破坏循环双链表，链表尾的指向null，能够单向循环，另一个方向为普通链表
		head.getPrev_run().setNext_run(null);
	}
	
	
	public PCB[] getExpired() {
		return expired;
	}
	public void setExpired(PCB[] expired) {
		this.expired = expired;
	}
	public PCB[] getActive() {
		return active;
	}
	public void setActive(PCB[] active) {
		this.active = active;
	}
	public boolean isNewPcb() {
		return newPcb;
	}
	public void setNewPcb(boolean newPcb) {
		this.newPcb = newPcb;
	}
	
	
	
}
