package scheduler;

import PCB.PCB;
import queue.ReadyQueue;

public class RoundRobin {
	private  int  time_slice;   //时间片长度
	private int time_now; 		//当前时间       
	public ReadyQueue rqueue;	//设置一个空的就绪队列
	int pcb_num=-1;				//设置pcb最大数量

	public RoundRobin() {
		time_now = 0;    		//初始时间为0
		time_slice = 2;   		 //设置时间片长度
		rqueue = new ReadyQueue();
	}
	public ReadyQueue rqueueInit(PCB[] pcb ) {	 	//初始化就绪队列，将进程列表转换为待执行的就绪队列（双向循环链表）,进程还未开始执行
		
		for(int i=0;i<pcb.length;i++)
		{
			rqueue.addLast(pcb[i]);
			pcb_num++;
		}
		
		return rqueue;	
	}
	public ReadyQueue run(){											//只执行当前就绪队列中的第一个pcb
		if(rqueue.isEmpty())	
		{
			System.out.println("当前队列为空，无法执行");
			return rqueue;
		}
		
		PCB run_pcb = rqueue.head.getNext_run();
		int i,j;
		for(i=0;i<pcb_num;i++) {
			for(j=0;j<i;j++) {
				if(run_pcb.getTime_slice()>run_pcb.getNext_run().getTime_slice()) {
					int time=run_pcb.getTime_slice();
					run_pcb.setTime_slice(run_pcb.getNext_run().getTime_slice());
					run_pcb.getNext_run().setTime_slice(time);
				}
			}
		}
		
		if(run_pcb.getTime_slice()<=time_slice) {
			System.out.print(time_now +"\t\t"+run_pcb.getName()+"\t\t"+run_pcb.getTime_slice()+"\t\t");
			rqueue.deleteFirst();
			time_now +=  run_pcb.getTime_slice();
			run_pcb.setTime_slice(0);
			run_pcb.setState("结束");		
		}
		else {
			System.out.print(time_now +"\t\t"+run_pcb.getName()+"\t\t"+time_slice+"\t\t");
			rqueue.deleteFirst();
			rqueue.addLast(run_pcb);
			time_now +=  time_slice;
			run_pcb.setTime_slice(run_pcb.getTime_slice() - time_slice);			
		}	
		rqueue.show_name();
		return rqueue;
	}
	
	public ReadyQueue run_in_time(int time) {					//按规定时间执行就绪队列		
		int run_start = time_now;								//记录起始时间
		int run_time = 0;										//运行的时间
		while(!rqueue.isEmpty()) {			
			run();
			run_time=time_now-run_start;						//更新运行时间
			if(time - run_time <= time_slice) {				
				PCB run_pcb = rqueue.head.getNext_run();
				
				do {
					
					if(run_pcb.getTime_slice()== time-run_time)
					{
						run();
						return rqueue;
					}
					else if(run_pcb.getTime_slice()>time - run_time)
					{
						System.out.print(time_now +"\t\t"+run_pcb.getName()+"\t\t"+(time - run_time)+"\t\t");
						time_now +=time_slice;
						run_pcb.setTime_slice(run_pcb.getTime_slice()-time_slice);
						rqueue.show_name();
						return rqueue;
					}
					else {
						run();
						run_time=time_now-run_start;						
					}
					
				}while(run_time==time);				
				return rqueue;
			}
		}
		System.out.println("进程执行完毕，执行时间"+run_time+"少于规定时间"+time);
		return rqueue;
	}
	
	public void run_all() {									//执行完就绪队列，使其为空
		while(!rqueue.isEmpty()) {
			run();
		}
	}
	

}
